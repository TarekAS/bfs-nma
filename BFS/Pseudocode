Host:
-----
Input:  *.mtx: coo-matrix representing a graph.
Ouput:  nodeLevel: distance to each node from the root of the graph.

Load COO matrix from .mtx file.
Convert COO matrix to CSR Matrix.
Split the rowPtrs (and associated colIdxs) into d DPUs.
Seed each DPU with:
  Stack:  numNodes - numNeighbors - totalNumNodes - nodeIdx - currentLevel
  Heap:   nodePtrs - neighbors - nodeLevels - visited - nextFrontier
Loop:
  Launch DPUs -> DPU Pseudocode
  Collect the "nextFrontier" from each DPU
  Get the union of the "nextFrontiers"
  For each node, set its nodeLevel to the currentLevel if its bit is set in the union.
  Broadcast to all DPUs:
    union of all nextFrontiers
    currentLevel
  If union of nextFrontiers is 0, break.
Get the nodeLevel from each DPU
Print nodeLevel


DPU: (assuming single tasklet)
----
MRAM:
  numNodes        ->  uint32_t        number of nodes for this DPU (V/d).
  numNeighbors    ->  uint32_t        number of neighbors for this DPU (N/d).
  totalNumNodes   ->  uint32_t        number of nodes globally (V).
  nodeIdx         ->  uint32_t        Index at which the global nodes were sliced for this DPU.
                                      i.e. [nodeIdx, nodeIdx+numNodes[ is the range of nodes for this DPU
                                      Used by the DPU to index the nextFrontier and visited bitfields.
  nodePtrs        ->  V/d * uint32_t  This DPU's share of nodes.
  neighbors       ->  N/d * uint32_t  This DPU's share of neighbors.
  nextFrontier    ->  V * 1-bit       At the start, represent the global currentFrontier.
                                      The DPU slices it into local currentFrontier via nodeIdx, clears it,
                                      the adds to it all unvisited neighbors.
                                      CPU collects it and repeat.
  currentLevel    ->  uint32_t        The currentLevel. Used to update nodeLevel.
  nodeLevel       ->  V/d * uint32_t  The final output of the DPU. Collected by the CPU at the end of all iterations.
  visited         ->  V * 1-bit

Load parameters from MRAM.
Update visisted nodes based on nextFrontier
currentFrontier := V/d * 1-bit
Take our part of the nextFrontier as the currentFrontier 
Update the nodeLevel (if currentFrontier == 1, nodeLevel = currentLevel) TODO: Understand this part
Clear nextFrontier

BFS:
  For each node in the currentFrontier:
    For each neighbor of this node:
      if neighbor is not visted:
        add neighbor to nextFrontier (critical section)

Milestones:
-----------
- Basic functionality 
- Add tasklets
- Split rows based on byte size
- CPU BFS
